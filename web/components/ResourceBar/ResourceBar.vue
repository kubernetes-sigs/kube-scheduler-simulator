<template>
  <v-navigation-drawer
    fixed
    right
    temporary
    bottom
    width="70%"
    v-model="drawer"
  >
    <BarHeader
      title="Resource"
      :deleteOnClick="deleteOnClick"
      :applyOnClick="applyOnClick"
      :editmodeOnChange="
        () => {
          editmode = !editmode
        }
      "
      :enableDeleteBtn="selected && !selected.isNew"
      :enableEditmodeSwitch="selected && !selected.isNew"
    />

    <v-divider></v-divider>

    <template v-if="editmode">
      <v-spacer v-for="n in 3" :key="n" />
      <v-divider></v-divider>

      <YamlEditor v-model="formData" />
    </template>

    <template v-if="!editmode">
      <SchedulingResults />
      <ResourceDefinitionTree :items="treeData" />
      <!-- This is need to avoid bug on vuetify -->
      <div style="height: 80%;"></div>
    </template>
  </v-navigation-drawer>
</template>
<script lang="ts">
import {
  ref,
  computed,
  inject,
  watch,
  defineComponent,
} from '@nuxtjs/composition-api'
import yaml from 'js-yaml'
import PodStoreKey from '../StoreKey/PodStoreKey'
import { objectToTreeViewData } from '../lib/util'
import NodeStoreKey from '../StoreKey/NodeStoreKey'
import PersistentVolumeStoreKey from '../StoreKey/PVStoreKey'
import PersistentVolumeClaimStoreKey from '../StoreKey/PVCStoreKey'
import StorageClassStoreKey from '../StoreKey/StorageClassStoreKey'
import SchedulerConfigurationStoreKey from '../StoreKey/SchedulerConfigurationStoreKey'
import YamlEditor from './YamlEditor.vue'
import SchedulingResults from './SchedulingResults.vue'
import ResourceDefinitionTree from './DefinitionTree.vue'
import BarHeader from './BarHeader.vue'
import {
  V1Node,
  V1PersistentVolumeClaim,
  V1PersistentVolume,
  V1Pod,
  V1StorageClass,
} from '@kubernetes/client-node'
import SnackBarStoreKey from '../StoreKey/SnackBarStoreKey'
import { SchedulerConfiguration } from '~/api/v1/types'

type Resource =
  | V1Pod
  | V1Node
  | V1PersistentVolumeClaim
  | V1PersistentVolume
  | V1StorageClass
  | SchedulerConfiguration

interface Store {
  readonly selected: object | null
  resetSelected(): void
  apply(r: Resource, onServerError: (msg: string) => void): Promise<void>
  delete(name: string): Promise<void>
  fetchSelected(): Promise<void>
}

interface SelectedItem {
  isNew: boolean
  item: Resource
  resourceKind: string
}

export default defineComponent({
  components: {
    YamlEditor,
    BarHeader,
    ResourceDefinitionTree,
    SchedulingResults,
  },
  setup() {
    var store: Store | null = null

    // inject stores
    const podstore = inject(PodStoreKey)
    if (!podstore) {
      throw new Error(`${PodStoreKey} is not provided`)
    }
    const nodestore = inject(NodeStoreKey)
    if (!nodestore) {
      throw new Error(`${NodeStoreKey} is not provided`)
    }
    const pvstore = inject(PersistentVolumeStoreKey)
    if (!pvstore) {
      throw new Error(`${pvstore} is not provided`)
    }
    const pvcstore = inject(PersistentVolumeClaimStoreKey)
    if (!pvcstore) {
      throw new Error(`${pvcstore} is not provided`)
    }
    const storageclassstore = inject(StorageClassStoreKey)
    if (!storageclassstore) {
      throw new Error(`${StorageClassStoreKey} is not provided`)
    }
    const schedulerconfigurationstore = inject(SchedulerConfigurationStoreKey)
    if (!schedulerconfigurationstore) {
      throw new Error(`${SchedulerConfigurationStoreKey} is not provided`)
    }

    const snackbarstore = inject(SnackBarStoreKey)
    if (!snackbarstore) {
      throw new Error(`${SnackBarStoreKey} is not provided`)
    }

    const treeData = ref(objectToTreeViewData(null))

    // for edit mode
    const formData = ref('')

    // boolean to switch some view
    const drawer = ref(false)
    const editmode = ref(false)

    // watch each selected resource
    const selected = ref(null as SelectedItem | null)
    const pod = computed(() => podstore.selected)
    watch(pod, () => {
      store = podstore
      selected.value = pod.value
    })

    const node = computed(() => nodestore.selected)
    watch(node, () => {
      store = nodestore
      selected.value = node.value
    })

    const pv = computed(() => pvstore.selected)
    watch(pv, () => {
      store = pvstore
      selected.value = pv.value
    })

    const pvc = computed(() => pvcstore.selected)
    watch(pvc, () => {
      store = pvcstore
      selected.value = pvc.value
    })

    const sc = computed(() => storageclassstore.selected)
    watch(sc, () => {
      store = storageclassstore
      selected.value = sc.value
    })

    const config = computed(() => schedulerconfigurationstore.selected)
    watch(config, () => {
      store = schedulerconfigurationstore
      selected.value = config.value
    })

    watch(selected, (newVal, oldVal) => {
      if (selected.value) {
        if (!oldVal) {
          fetchSelected().then((_) => {
            if (selected.value) {
              editmode.value = selected.value.isNew

              formData.value = yaml.dump(selected.value.item)
              treeData.value = objectToTreeViewData(selected.value.item)
              drawer.value = true
            }
          })
        }
      }
    })

    watch(drawer, (newValue, _) => {
      if (!newValue) {
        // reset editmode.
        editmode.value = false
        if (store) {
          store.resetSelected()
        }
        store = null
        selected.value = null
      }
    })

    const fetchSelected = async () => {
      if (store) {
        await store.fetchSelected()
      }
    }

    const setServerErrorMessage = (error: string) => {
      snackbarstore.setServerErrorMessage(error)
    }

    const applyOnClick = () => {
      if (store) {
        const y = yaml.load(formData.value)
        store.apply(y, setServerErrorMessage)
      }
      drawer.value = false
    }

    const deleteOnClick = () => {
      if (selected.value?.resourceKind != 'SchedulerConfiguration') {
        //@ts-ignore // Only SchedulerConfiguration don't have the metadata field.
        if (selected.value?.item.metadata?.name && store) {
          //@ts-ignore
          store.delete(selected.value.item.metadata.name)
        }
      }
      drawer.value = false
    }

    return {
      drawer,
      editmode,
      selected,
      formData,
      treeData,
      applyOnClick,
      deleteOnClick,
    }
  },
})
</script>
